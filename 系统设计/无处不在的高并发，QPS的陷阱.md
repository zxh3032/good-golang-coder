# 一、引言：为什么我们总在谈高并发？

如果你最近参加过后端开发岗位的面试，极大概率会遇到这样的问题：

- 如果系统的 QPS 突然到 10万，你会怎么设计？
- 秒杀场景你会怎么设计？
- 并发请求量过高，数据库顶不住怎么办？
- 高并发场景下如何保证系统稳定性？

这几乎成为技术面试的保留节目，当一个面试官提到MySQL、Redis或者系统设计时，极大可能性会提到这样的系统设计题。

但一个很奇怪的现象是：**真正在线上工作的人，反而很少真的会遇到这些极端的场景**。

那么问题来了——为什么我们总是在谈高并发？高并发到底是一个什么类型的问题？要怎么解决？

## 高并发，正在被神化

无论是在大众的技术社区，还是私下中的技术面试、技术讨论中，高并发几乎成为了一种能力标签：

- 能讲清楚高并发 → 技术强
- 写过秒杀系统 → 架构能力好
- 能画出复杂的机构图 → 有经验

但现实中，大多是系统是这样的情况：

- 日常 QPS 可能只有几十到几百
- 峰值流量可预测
- 核心瓶颈往往不在并发，而在设计

可我们仍然执着于问，如果突然来 100万 QPS 呢？

这类问题本身就带着一个默认的前提：你的系统必须在任何情况下都保持完美运行。

然而，现实工程从来不是这样。无论国内还是国外，无论多高的用户量级，都不敢保证自己的系统能够在任何情况下都保持完美运行。

但是，就是存在一部分人，会让你在短短几分钟内，在一个几乎完全架空的场景下（如一个订单表、一个用户表，设计一个秒杀系统）设计一个“完美”的系统。

## 我们谈的高并发，大多数情况下并不存在

在真实的业务中，高并发通常有三个前提条件：

1. 用户量级足够大
2. 用户行为高度集中
3. 请求路径无法削峰或缓冲

但这三个条件，很少同时成立。

举一个简单的例子：

- 一个日活 10万+ 的系统
- 平均每人每天有 20 次操作
- 总请求数 ≈ 200万/天
- 平均 QPS ≈ 23

哪怕在高峰期放大 10 倍，也不过 200 多的 QPS

这种情况，距离所谓的“高并发系统”，其实还非常遥远。

但是在面试中，我们往往会被带入这样一个假设：

> 现在你的系统每秒有 10 万请求……

这个前提本身，往往就是未经验证的。

## 高并发问题，很多时候是被“问”出来的

更现实的一点是：很多高并发问题，不是业务带来的，而是面试设计出来的。

> 更有甚者，你想基于业务和他聊，他告诉你只想要和你聊相关的技术问题。

比如：

- 不考虑缓存，直接问数据库怎么扛
- 不允许降级，要求数据的强一致性
- 不允许一步，要求实时返回
- 不允许失败，要求 100% 成功

在这样一系列严苛的前提下，任何系统都会崩溃。从此，软件工程不存在了。

往往令人绷不住的是，你在面试的时候被这样一番拷打，在结束之后想要从网上或者GPT中获取这个抽象问题的答案。但是往往得不到你想要的结果，GPT甚至还会告诉你和这个问题偏离很远的答案。

这是因为，在真实的工程中，往往是和面试相反的，在这里：

- 可以缓存
- 可以有延迟
- 可以失败然后重试
- 可以补偿
- 可以牺牲掉一部分一致性

于是你发现了一个很有意思的现象：

> **显示系统解决问题的方式，和面试中的标准答案，往往是相反的。**

## 我们真正困惑的，其实不是技术

很多人以为自己搞不懂高并发，是因为：

- 中间件不熟
- 架构经验不足
- 底层原理没掌握
- ……

但实际上，真正让人困惑的，是这三个问题：

1. 这个场景真的huo you这么高的并发

# 二、QPS 的陷阱：你以为在谈性能，其实什么都没说明


# 三、除了 QPS 我们还要衡量什么？


# 四、真正的高并发来自哪里？


# 五、高并发系统真正要解决的三个问题


# 六、从工程角度看，高并发的解决手段


# 七、回到现实 —— 我们该如何应对面试中的“高并发”问题？


# 八、总结：高并发不是技术问题，而是认知问题

